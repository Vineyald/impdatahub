# automacao/management/commands/baixar_relatorios.py

from django.core.management.base import BaseCommand, CommandError
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.support.expected_conditions import staleness_of, invisibility_of_element_located, presence_of_element_located
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from webdriver_manager.chrome import ChromeDriverManager
from selenium.common.exceptions import (
    TimeoutException,
    NoSuchElementException,
    ElementNotInteractableException,
    WebDriverException,
)
import time
import os
import logging
import threading
from django.conf import settings
from datetime import datetime
import json

# Configurar o logger
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


class Command(BaseCommand):
    help = 'Automatiza o login no Tiny Olist e baixa os relatórios disponíveis para múltiplas contas.'

    def add_arguments(self, parser):
        parser.add_argument(
            '--links',
            type=str,
            required=True,
            help='Dicionário JSON contendo os links para cada conta no formato {"Servi": "link_servi", "Imp": "link_imp"}'
        )

    def handle(self, *args, **options):
        links_json = options['links']
        try:
            links = json.loads(links_json)
            if not isinstance(links, dict):
                raise ValueError
            if 'Servi' not in links or 'Imp' not in links:
                raise ValueError("O dicionário de links deve conter as chaves 'Servi' e 'Imp'.")
        except ValueError:
            raise CommandError(
                "O argumento --links deve ser um dicionário JSON válido com as chaves 'Servi' e 'Imp'. Exemplo: "
                "'{\"Servi\": \"https://link_servi.com\", \"Imp\": \"https://link_imp.com\"}'"
            )

        accounts = [
            {
                'type': 'Servi',
                'username': settings.TINY_OLIST_USERNAME_SERVI,
                'password': settings.TINY_OLIST_PASSWORD,
                'download_dir': os.path.join(os.getcwd(), 'temporary_files\servi')
            },
            {
                'type': 'Imp',
                'username': settings.TINY_OLIST_USERNAME_IMP,
                'password': settings.TINY_OLIST_PASSWORD,
                'download_dir': os.path.join(os.getcwd(), 'temporary_files\imp')
            },
        ]

        threads = []

        for account in accounts:
            account_type = account['type']
            link = links.get(account_type)
            if not link:
                self.stderr.write(self.style.ERROR(
                    f"Link não fornecido para a conta do tipo '{account_type}'."
                ))
                logger.error(f"Link não fornecido para a conta do tipo '{account_type}'.")
                continue  # Pula para a próxima conta

            thread = threading.Thread(target=self.download_reports, args=(account, link))
            threads.append(thread)
            thread.start()

        for thread in threads:
            thread.join()

        self.stdout.write(self.style.SUCCESS("Todos os downloads foram processados."))
        logger.info("Todos os downloads foram processados.")

    def download_reports(self, account: dict, link: str) -> None:
        username = account['username']
        password = account['password']
        download_dir = account['download_dir']

        # Verify configuration variables
        if not username or not password:
            self.stderr.write(self.style.ERROR("TINY_OLIST_USERNAME or TINY_OLIST_PASSWORD not set."))
            return

        # Create download directory if it doesn't exist
        if not os.path.exists(download_dir):
            os.makedirs(download_dir)
            logger.info(f"Download directory created at {download_dir}")

        # Configure Chrome options
        chrome_options = Options()
        #chrome_options.add_argument('--headless=new')  # Run Chrome headless
        chrome_options.add_argument('--no-sandbox')
        chrome_options.add_argument('--disable-dev-shm-usage')
        prefs = {
            "download.default_directory": download_dir,
            "download.prompt_for_download": False,
            "download.directory_upgrade": True,
            "safebrowsing.enabled": True
        }
        chrome_options.add_experimental_option("prefs", prefs)

        # Initialize WebDriver with webdriver-manager
        try:
            service = Service(ChromeDriverManager().install())  # Automatically managed
            driver = webdriver.Chrome(service=service, options=chrome_options)
            logger.info("WebDriver initialized with webdriver-manager.")
        except WebDriverException as e:
            self.stderr.write(self.style.ERROR(f"Error initializing WebDriver: {e}"))
            return

        wait = WebDriverWait(driver, 20)  # Maximum wait time

        try:
            # Login to Olist Tiny
            driver.get('https://erp.tiny.com.br/login/')
            username_field = wait.until(EC.presence_of_element_located((By.NAME, 'username')))
            username_field.clear()
            username_field.send_keys(username)

            password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))
            password_field.clear()
            password_field.send_keys(password)

            login_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), "entrar no Olist Tiny")]')))
            login_button.click()

            time.sleep(6)  # Wait for login response

            # Check if login was successful
            try:
                WebDriverWait(driver, 15).until(
                    EC.presence_of_element_located((By.CLASS_NAME, "modal-dialog"))
                )
                modal_title = driver.find_element(By.CLASS_NAME, "modal-title").text
                if "Este usuário já está logado em outro dispositivo" in modal_title:
                    # Click on the "login" button in the modal
                    login_modal_button = driver.find_element(By.XPATH, "//button[contains(text(), 'login')]")
                    login_modal_button.click()
                else:
                    logger.info("Modal with multiple login message not found.")
            except NoSuchElementException:
                logger.info("No modal detected.")
            except TimeoutException:
                logger.info("No modal detected within the expected time.")
            except Exception as e:
                logger.error(f"Error logging in to Olist Tiny for {username}: {e}")
                self.stderr.write(self.style.ERROR(f"Error logging in to Olist Tiny for {username}: {e}"))

            # Navigate to the specific URL for the account
            time.sleep(5)
            driver.get(link)

            # Interact with the page as requested
            time.sleep(10)
            element = driver.find_element(By.CSS_SELECTOR, 'a.filter-label.filter-toggle.has-tipsy-top')
            element.click()

            time.sleep(5)
           
        except TimeoutException as te:
            logger.error(f"Timeout waiting for an element for {username}: {te}")
            self.stderr.write(self.style.ERROR(f"Timeout waiting for an element for {username}: {te}"))
        except Exception as e:
            logger.error(f"Error while downloading report for {username}: {e}")
            self.stderr.write(self.style.ERROR(f"Error while downloading report for {username}: {e}"))
        finally:
            driver.quit()
            logger.info(f"Browser closed for {username}.")

    def wait_for_download(self, download_dir, timeout=120):
        """
        Espera até que todos os arquivos de download sejam concluídos no diretório especificado.
        """
        seconds = 0
        download_complete = False
        while not download_complete and seconds < timeout:
            time.sleep(1)
            download_complete = True
            for filename in os.listdir(download_dir):
                if filename.endswith('.crdownload'):
                    download_complete = False
                    break
            seconds += 1
            if seconds % 10 == 0:
                logger.info(f"Aguardando conclusão do download... {seconds} segundos passados.")
        if not download_complete:
            raise Exception("O download não foi concluído dentro do tempo esperado.")

    def wait_for_loading_bar(self, driver: webdriver.Chrome, timeout: int = 250) -> None:
        """
        Waits until the loading bar disappears.
        """
        wait = WebDriverWait(driver, timeout)
    
        try:
            # Wait until the loading bar is invisible
            wait.until_not(EC.visibility_of_element_located(
                (By.CSS_SELECTOR, '.card-body-space-progress')
            ))
    
        except TimeoutException as timeout_exception:
            raise Exception("The loading bar did not disappear within the expected time.") from timeout_exception
        except Exception as exception:
            raise Exception("An error occurred while waiting for the loading bar to disappear.") from exception
